
Project1.4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ae  00800100  00000688  0000071c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000688  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  008001ae  008001ae  000007ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000007ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000007fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  0000083c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a5d  00000000  00000000  00000924  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c1c  00000000  00000000  00002381  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b6e  00000000  00000000  00002f9d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000017c  00000000  00000000  00003b0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005de  00000000  00000000  00003c88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000009f8  00000000  00000000  00004266  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  00004c5e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e8 e8       	ldi	r30, 0x88	; 136
  a0:	f6 e0       	ldi	r31, 0x06	; 6
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ae 3a       	cpi	r26, 0xAE	; 174
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	ae ea       	ldi	r26, 0xAE	; 174
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a9 3b       	cpi	r26, 0xB9	; 185
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	37 d1       	rcall	.+622    	; 0x332 <main>
  c4:	df c2       	rjmp	.+1470   	; 0x684 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <Keypad_Init>:
	{'*', '0', '#'}   // 3번째 행: '*', '0', '#'
};

// Keypad_Init 함수: 키패드를 초기화하는 함수
void Keypad_Init() {
	KEYPAD_DDR = 0xF0;         // 상위 4비트 (컬럼) 출력, 하위 4비트 (행) 입력
  c8:	80 ef       	ldi	r24, 0xF0	; 240
  ca:	81 bb       	out	0x11, r24	; 17
	// 처음에 모든 컬럼을 'Low'로 설정하여 초기 상태를 만듬
	KEYPAD_PORT &= ~((1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7));
  cc:	82 b3       	in	r24, 0x12	; 18
  ce:	8f 70       	andi	r24, 0x0F	; 15
  d0:	82 bb       	out	0x12, r24	; 18
  d2:	08 95       	ret

000000d4 <keypad_get_char>:
}

// keypad_get_char 함수: 키패드에서 눌린 버튼을 확인하는 함수
char keypad_get_char(void) {
  d4:	cf 93       	push	r28
  d6:	df 93       	push	r29
  d8:	00 d0       	rcall	.+0      	; 0xda <keypad_get_char+0x6>
  da:	1f 92       	push	r1
  dc:	cd b7       	in	r28, 0x3d	; 61
  de:	de b7       	in	r29, 0x3e	; 62
	char key = '\0'; // 초기값은 '\0' (아무것도 눌리지 않았다는 의미)

	// 컬럼을 차례로 'High'로 만들어서 각 행을 확인
	unsigned char col_select_pattern[] = {
  e0:	80 e1       	ldi	r24, 0x10	; 16
  e2:	89 83       	std	Y+1, r24	; 0x01
  e4:	80 e2       	ldi	r24, 0x20	; 32
  e6:	8a 83       	std	Y+2, r24	; 0x02
  e8:	80 e4       	ldi	r24, 0x40	; 64
  ea:	8b 83       	std	Y+3, r24	; 0x03
		0x20, // PD5를 High로, 나머지는 Low
		0x40  // PD6를 High로, 나머지는 Low
	};

	// 각 컬럼을 순서대로 확인
	for (int c = 0; c < 3; c++) {
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	2c c0       	rjmp	.+88     	; 0x14a <keypad_get_char+0x76>
		// 컬럼을 선택하고, 다른 컬럼은 Low로 설정
		KEYPAD_PORT = (KEYPAD_PORT & 0x0F) | col_select_pattern[c];
  f2:	22 b3       	in	r18, 0x12	; 18
  f4:	e1 e0       	ldi	r30, 0x01	; 1
  f6:	f0 e0       	ldi	r31, 0x00	; 0
  f8:	ec 0f       	add	r30, r28
  fa:	fd 1f       	adc	r31, r29
  fc:	e8 0f       	add	r30, r24
  fe:	f9 1f       	adc	r31, r25
 100:	30 81       	ld	r19, Z
 102:	2f 70       	andi	r18, 0x0F	; 15
 104:	23 2b       	or	r18, r19
 106:	22 bb       	out	0x12, r18	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 108:	28 e1       	ldi	r18, 0x18	; 24
 10a:	2a 95       	dec	r18
 10c:	f1 f7       	brne	.-4      	; 0x10a <keypad_get_char+0x36>
 10e:	00 c0       	rjmp	.+0      	; 0x110 <keypad_get_char+0x3c>
		_delay_us(5); // 안정화 대기 시간

		// 각 행에서 눌린 키 확인
		if ((KEYPAD_PIN & ROW0_PIN_MASK) == ROW0_PIN_MASK) { key = keypad_map[0][c]; break; }
 110:	80 9b       	sbis	0x10, 0	; 16
 112:	05 c0       	rjmp	.+10     	; 0x11e <keypad_get_char+0x4a>
 114:	fc 01       	movw	r30, r24
 116:	e8 5f       	subi	r30, 0xF8	; 248
 118:	fe 4f       	sbci	r31, 0xFE	; 254
 11a:	80 81       	ld	r24, Z
 11c:	1a c0       	rjmp	.+52     	; 0x152 <keypad_get_char+0x7e>
		if ((KEYPAD_PIN & ROW1_PIN_MASK) == ROW1_PIN_MASK) { key = keypad_map[1][c]; break; }
 11e:	81 9b       	sbis	0x10, 1	; 16
 120:	05 c0       	rjmp	.+10     	; 0x12c <keypad_get_char+0x58>
 122:	fc 01       	movw	r30, r24
 124:	e8 5f       	subi	r30, 0xF8	; 248
 126:	fe 4f       	sbci	r31, 0xFE	; 254
 128:	83 81       	ldd	r24, Z+3	; 0x03
 12a:	13 c0       	rjmp	.+38     	; 0x152 <keypad_get_char+0x7e>
		if ((KEYPAD_PIN & ROW2_PIN_MASK) == ROW2_PIN_MASK) { key = keypad_map[2][c]; break; }
 12c:	82 9b       	sbis	0x10, 2	; 16
 12e:	05 c0       	rjmp	.+10     	; 0x13a <keypad_get_char+0x66>
 130:	fc 01       	movw	r30, r24
 132:	e8 5f       	subi	r30, 0xF8	; 248
 134:	fe 4f       	sbci	r31, 0xFE	; 254
 136:	86 81       	ldd	r24, Z+6	; 0x06
 138:	0c c0       	rjmp	.+24     	; 0x152 <keypad_get_char+0x7e>
		if ((KEYPAD_PIN & ROW3_PIN_MASK) == ROW3_PIN_MASK) { key = keypad_map[3][c]; break; }
 13a:	83 9b       	sbis	0x10, 3	; 16
 13c:	05 c0       	rjmp	.+10     	; 0x148 <keypad_get_char+0x74>
 13e:	fc 01       	movw	r30, r24
 140:	e8 5f       	subi	r30, 0xF8	; 248
 142:	fe 4f       	sbci	r31, 0xFE	; 254
 144:	81 85       	ldd	r24, Z+9	; 0x09
 146:	05 c0       	rjmp	.+10     	; 0x152 <keypad_get_char+0x7e>
		0x20, // PD5를 High로, 나머지는 Low
		0x40  // PD6를 High로, 나머지는 Low
	};

	// 각 컬럼을 순서대로 확인
	for (int c = 0; c < 3; c++) {
 148:	01 96       	adiw	r24, 0x01	; 1
 14a:	83 30       	cpi	r24, 0x03	; 3
 14c:	91 05       	cpc	r25, r1
 14e:	8c f2       	brlt	.-94     	; 0xf2 <keypad_get_char+0x1e>
	KEYPAD_PORT &= ~((1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7));
}

// keypad_get_char 함수: 키패드에서 눌린 버튼을 확인하는 함수
char keypad_get_char(void) {
	char key = '\0'; // 초기값은 '\0' (아무것도 눌리지 않았다는 의미)
 150:	80 e0       	ldi	r24, 0x00	; 0
		if ((KEYPAD_PIN & ROW2_PIN_MASK) == ROW2_PIN_MASK) { key = keypad_map[2][c]; break; }
		if ((KEYPAD_PIN & ROW3_PIN_MASK) == ROW3_PIN_MASK) { key = keypad_map[3][c]; break; }
	}

	// 스캔 후 컬럼을 다시 모두 'Low'로 설정하여 초기 상태로 복귀
	KEYPAD_PORT &= ~((1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7));
 152:	92 b3       	in	r25, 0x12	; 18
 154:	9f 70       	andi	r25, 0x0F	; 15
 156:	92 bb       	out	0x12, r25	; 18

	return key; // 눌린 키를 반환
}
 158:	0f 90       	pop	r0
 15a:	0f 90       	pop	r0
 15c:	0f 90       	pop	r0
 15e:	df 91       	pop	r29
 160:	cf 91       	pop	r28
 162:	08 95       	ret

00000164 <Port_Init>:
﻿#include "lcd.h"

// 포트 초기화 함수
void Port_Init(void) {
	DDRC = 0xFF;	// PORTC를 출력으로 설정 (LCD 데이터 핀)
 164:	8f ef       	ldi	r24, 0xFF	; 255
 166:	84 bb       	out	0x14, r24	; 20
	DDRG = 0x0F;	// PORTG의 하위 4비트를 출력으로 설정 (PG0, PG1, PG2는 LCD 제어핀)
 168:	8f e0       	ldi	r24, 0x0F	; 15
 16a:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
 16e:	08 95       	ret

00000170 <LCD_Data>:
}

// LCD에 데이터를 전송하는 함수
void LCD_Data(Byte ch) {
	LCD_CTRL |= (1 << LCD_RS);  // RS=1 (데이터 모드)
 170:	e5 e6       	ldi	r30, 0x65	; 101
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	90 81       	ld	r25, Z
 176:	91 60       	ori	r25, 0x01	; 1
 178:	90 83       	st	Z, r25
	LCD_CTRL &= ~(1 << LCD_RW); // RW=0 (쓰기 모드)
 17a:	90 81       	ld	r25, Z
 17c:	9d 7f       	andi	r25, 0xFD	; 253
 17e:	90 83       	st	Z, r25
	LCD_CTRL |= (1 << LCD_EN);  // EN High (데이터 전송 시작)
 180:	90 81       	ld	r25, Z
 182:	94 60       	ori	r25, 0x04	; 4
 184:	90 83       	st	Z, r25
 186:	96 ef       	ldi	r25, 0xF6	; 246
 188:	9a 95       	dec	r25
 18a:	f1 f7       	brne	.-4      	; 0x188 <LCD_Data+0x18>
	_delay_us(50); // 딜레이 (이 딜레이는 데이터 전송 완료 후 잠시 기다리는 시간)
	LCD_WDATA = ch;             // 데이터 출력
 18c:	85 bb       	out	0x15, r24	; 21
 18e:	86 ef       	ldi	r24, 0xF6	; 246
 190:	8a 95       	dec	r24
 192:	f1 f7       	brne	.-4      	; 0x190 <LCD_Data+0x20>
	_delay_us(50); // 다시 딜레이
	LCD_CTRL &= ~(1 << LCD_EN); // EN Low (데이터 전송 완료)
 194:	80 81       	ld	r24, Z
 196:	8b 7f       	andi	r24, 0xFB	; 251
 198:	80 83       	st	Z, r24
 19a:	08 95       	ret

0000019c <LCD_Comm>:
}

// LCD에 명령어를 전송하는 함수
void LCD_Comm(Byte ch) {
	LCD_CTRL &= ~(1 << LCD_RS); // RS=0 (명령 모드)
 19c:	e5 e6       	ldi	r30, 0x65	; 101
 19e:	f0 e0       	ldi	r31, 0x00	; 0
 1a0:	90 81       	ld	r25, Z
 1a2:	9e 7f       	andi	r25, 0xFE	; 254
 1a4:	90 83       	st	Z, r25
	LCD_CTRL &= ~(1 << LCD_RW); // RW=0 (쓰기 모드)
 1a6:	90 81       	ld	r25, Z
 1a8:	9d 7f       	andi	r25, 0xFD	; 253
 1aa:	90 83       	st	Z, r25
	LCD_CTRL |= (1 << LCD_EN);  // EN High (명령 전송 시작)
 1ac:	90 81       	ld	r25, Z
 1ae:	94 60       	ori	r25, 0x04	; 4
 1b0:	90 83       	st	Z, r25
 1b2:	96 ef       	ldi	r25, 0xF6	; 246
 1b4:	9a 95       	dec	r25
 1b6:	f1 f7       	brne	.-4      	; 0x1b4 <LCD_Comm+0x18>
	_delay_us(50); // 딜레이
	LCD_WINST = ch;             // 명령어 출력
 1b8:	85 bb       	out	0x15, r24	; 21
 1ba:	86 ef       	ldi	r24, 0xF6	; 246
 1bc:	8a 95       	dec	r24
 1be:	f1 f7       	brne	.-4      	; 0x1bc <LCD_Comm+0x20>
	_delay_us(50); // 딜레이
	LCD_CTRL &= ~(1 << LCD_EN); // EN Low (명령 전송 완료)
 1c0:	80 81       	ld	r24, Z
 1c2:	8b 7f       	andi	r24, 0xFB	; 251
 1c4:	80 83       	st	Z, r24
 1c6:	08 95       	ret

000001c8 <LCD_CHAR>:
}

// LCD에 문자 하나를 출력하는 함수
void LCD_CHAR(Byte c) {
	// CGROM 문자코드의 0x31 ~ 0xFF는 아스키코드와 일치함
	LCD_Data(c);  // 문자 데이터를 LCD로 출력
 1c8:	d3 df       	rcall	.-90     	; 0x170 <LCD_Data>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1ca:	86 e6       	ldi	r24, 0x66	; 102
 1cc:	9e e0       	ldi	r25, 0x0E	; 14
 1ce:	01 97       	sbiw	r24, 0x01	; 1
 1d0:	f1 f7       	brne	.-4      	; 0x1ce <LCD_CHAR+0x6>
 1d2:	00 00       	nop
 1d4:	08 95       	ret

000001d6 <LCD_STR>:
	_delay_ms(1); // 출력 후 딜레이
}

// LCD에 문자열을 출력하는 함수
void LCD_STR(Byte *str) {
 1d6:	cf 93       	push	r28
 1d8:	df 93       	push	r29
 1da:	ec 01       	movw	r28, r24
	// 문자열을 한 문자씩 출력 함수로 전달
	while (*str != 0) {
 1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <LCD_STR+0xc>
		LCD_CHAR(*str); // 문자를 하나씩 LCD로 출력
 1de:	f4 df       	rcall	.-24     	; 0x1c8 <LCD_CHAR>
		str++; // 다음 문자로 이동
 1e0:	21 96       	adiw	r28, 0x01	; 1
}

// LCD에 문자열을 출력하는 함수
void LCD_STR(Byte *str) {
	// 문자열을 한 문자씩 출력 함수로 전달
	while (*str != 0) {
 1e2:	88 81       	ld	r24, Y
 1e4:	81 11       	cpse	r24, r1
 1e6:	fb cf       	rjmp	.-10     	; 0x1de <LCD_STR+0x8>
		LCD_CHAR(*str); // 문자를 하나씩 LCD로 출력
		str++; // 다음 문자로 이동
	}
}
 1e8:	df 91       	pop	r29
 1ea:	cf 91       	pop	r28
 1ec:	08 95       	ret

000001ee <LCD_pos>:

// LCD에서 특정 위치로 커서를 이동시키는 함수 (열, 행 순서)
void LCD_pos(unsigned char col, unsigned char row) {
	unsigned char address;
	if (row == 0) {
 1ee:	61 11       	cpse	r22, r1
 1f0:	02 c0       	rjmp	.+4      	; 0x1f6 <LCD_pos+0x8>
		address = 0x80 + col; // 첫 번째 줄 (DDRAM 주소 0x00 - 0x0F에 해당)
 1f2:	80 58       	subi	r24, 0x80	; 128
 1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <LCD_pos+0xa>
		} else { // row == 1
		address = 0xC0 + col; // 두 번째 줄 (DDRAM 주소 0x40 - 0x4F에 해당)
 1f6:	80 54       	subi	r24, 0x40	; 64
	}
	LCD_Comm(address); // 계산된 주소로 커서 이동
 1f8:	d1 cf       	rjmp	.-94     	; 0x19c <LCD_Comm>
 1fa:	08 95       	ret

000001fc <LCD_Clear>:
}

// LCD 화면을 클리어하는 함수
void LCD_Clear(void) {
	// 화면을 클리어하는 명령어 0x01
	LCD_Comm(0x01);
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	ce df       	rcall	.-100    	; 0x19c <LCD_Comm>
 200:	8c ec       	ldi	r24, 0xCC	; 204
 202:	9c e1       	ldi	r25, 0x1C	; 28
 204:	01 97       	sbiw	r24, 0x01	; 1
 206:	f1 f7       	brne	.-4      	; 0x204 <LCD_Clear+0x8>
 208:	00 c0       	rjmp	.+0      	; 0x20a <LCD_Clear+0xe>
 20a:	00 00       	nop
 20c:	08 95       	ret

0000020e <LCD_Init>:
 20e:	8c ec       	ldi	r24, 0xCC	; 204
 210:	9c e1       	ldi	r25, 0x1C	; 28
 212:	01 97       	sbiw	r24, 0x01	; 1
 214:	f1 f7       	brne	.-4      	; 0x212 <LCD_Init+0x4>
 216:	00 c0       	rjmp	.+0      	; 0x218 <LCD_Init+0xa>
 218:	00 00       	nop
// LCD 초기화 함수
void LCD_Init(void) {
	// LCD 초기화 과정 (이미 Port_Init에서 설정되었으므로 생략 가능)
	// LCD_Comm(0x38); // 데이터 8비트 사용, 5X7도트, LCD 2열로 사용 (Function set)
	_delay_ms(2);
	LCD_Comm(0x38); // 함수 설정 (Function Set)
 21a:	88 e3       	ldi	r24, 0x38	; 56
 21c:	bf df       	rcall	.-130    	; 0x19c <LCD_Comm>
 21e:	8c ec       	ldi	r24, 0xCC	; 204
 220:	9c e1       	ldi	r25, 0x1C	; 28
 222:	01 97       	sbiw	r24, 0x01	; 1
 224:	f1 f7       	brne	.-4      	; 0x222 <LCD_Init+0x14>
 226:	00 c0       	rjmp	.+0      	; 0x228 <LCD_Init+0x1a>
 228:	00 00       	nop
	_delay_ms(2);
	LCD_Comm(0x38); // 함수 설정 (Function Set) 재설정
 22a:	88 e3       	ldi	r24, 0x38	; 56
 22c:	b7 df       	rcall	.-146    	; 0x19c <LCD_Comm>
 22e:	8c ec       	ldi	r24, 0xCC	; 204
 230:	9c e1       	ldi	r25, 0x1C	; 28
 232:	01 97       	sbiw	r24, 0x01	; 1
 234:	f1 f7       	brne	.-4      	; 0x232 <LCD_Init+0x24>
 236:	00 c0       	rjmp	.+0      	; 0x238 <LCD_Init+0x2a>
	_delay_ms(2);
	LCD_Comm(0x0e); // Display ON, Cursor ON, Blink OFF (Display on/off control)
 238:	00 00       	nop
 23a:	8e e0       	ldi	r24, 0x0E	; 14
 23c:	af df       	rcall	.-162    	; 0x19c <LCD_Comm>
 23e:	8c ec       	ldi	r24, 0xCC	; 204
 240:	9c e1       	ldi	r25, 0x1C	; 28
 242:	01 97       	sbiw	r24, 0x01	; 1
 244:	f1 f7       	brne	.-4      	; 0x242 <LCD_Init+0x34>
 246:	00 c0       	rjmp	.+0      	; 0x248 <LCD_Init+0x3a>
	_delay_ms(2);
	LCD_Comm(0x06); // Increment cursor, No display shift (Entry mode set)
 248:	00 00       	nop
 24a:	86 e0       	ldi	r24, 0x06	; 6
 24c:	a7 df       	rcall	.-178    	; 0x19c <LCD_Comm>
 24e:	8c ec       	ldi	r24, 0xCC	; 204
 250:	9c e1       	ldi	r25, 0x1C	; 28
 252:	01 97       	sbiw	r24, 0x01	; 1
 254:	f1 f7       	brne	.-4      	; 0x252 <LCD_Init+0x44>
 256:	00 c0       	rjmp	.+0      	; 0x258 <LCD_Init+0x4a>
	_delay_ms(2);
	LCD_Clear(); // LCD 화면 초기화
 258:	00 00       	nop
 25a:	d0 cf       	rjmp	.-96     	; 0x1fc <LCD_Clear>
 25c:	08 95       	ret

0000025e <led_set_color>:

// LED 색상 설정 함수
void led_set_color(unsigned char color_mask) {
	// Common Cathode 방식이므로, LED 핀이 LOW일 때 LED가 켜집니다.
	// 먼저 모든 LED 핀을 HIGH로 설정하여 끄기
	LED_PORT |= ((1 << LED_RED_PIN) | (1 << LED_GREEN_PIN) | (1 << LED_BLUE_PIN));
 25e:	93 b1       	in	r25, 0x03	; 3
 260:	97 60       	ori	r25, 0x07	; 7
 262:	93 b9       	out	0x03, r25	; 3

	// 주어진 color_mask에 해당하는 핀만 LOW로 설정하여 LED를 켬
	if (color_mask & (1 << LED_RED_PIN)) {
 264:	80 ff       	sbrs	r24, 0
 266:	03 c0       	rjmp	.+6      	; 0x26e <led_set_color+0x10>
		LED_PORT &= ~(1 << LED_RED_PIN); // 빨간색 LED 켜기
 268:	93 b1       	in	r25, 0x03	; 3
 26a:	9e 7f       	andi	r25, 0xFE	; 254
 26c:	93 b9       	out	0x03, r25	; 3
	}
	if (color_mask & (1 << LED_GREEN_PIN)) {
 26e:	81 ff       	sbrs	r24, 1
 270:	03 c0       	rjmp	.+6      	; 0x278 <led_set_color+0x1a>
		LED_PORT &= ~(1 << LED_GREEN_PIN); // 초록색 LED 켜기
 272:	93 b1       	in	r25, 0x03	; 3
 274:	9d 7f       	andi	r25, 0xFD	; 253
 276:	93 b9       	out	0x03, r25	; 3
	}
	if (color_mask & (1 << LED_BLUE_PIN)) {
 278:	82 ff       	sbrs	r24, 2
 27a:	03 c0       	rjmp	.+6      	; 0x282 <led_set_color+0x24>
		LED_PORT &= ~(1 << LED_BLUE_PIN); // 파란색 LED 켜기
 27c:	83 b1       	in	r24, 0x03	; 3
 27e:	8b 7f       	andi	r24, 0xFB	; 251
 280:	83 b9       	out	0x03, r24	; 3
 282:	08 95       	ret

00000284 <led_off>:
}

// 모든 LED 끄는 함수
void led_off(void) {
	// 모든 LED 핀을 HIGH로 설정하여 끄기 (Common Cathode 기준)
	LED_PORT |= ((1 << LED_RED_PIN) | (1 << LED_GREEN_PIN) | (1 << LED_BLUE_PIN));
 284:	83 b1       	in	r24, 0x03	; 3
 286:	87 60       	ori	r24, 0x07	; 7
 288:	83 b9       	out	0x03, r24	; 3
 28a:	08 95       	ret

0000028c <led_init>:
﻿#include "led.h"

// LED 초기화 함수
void led_init(void) {
	// LED 핀을 모두 출력으로 설정
	LED_DDR |= ((1 << LED_RED_PIN) | (1 << LED_GREEN_PIN) | (1 << LED_BLUE_PIN));
 28c:	82 b1       	in	r24, 0x02	; 2
 28e:	87 60       	ori	r24, 0x07	; 7
 290:	82 b9       	out	0x02, r24	; 2
	// 초기에는 모든 LED를 끈다 (Common Cathode 기준, HIGH로 출력)
	led_off();
 292:	f8 cf       	rjmp	.-16     	; 0x284 <led_off>
 294:	08 95       	ret

00000296 <reset_program>:

/**
 * @brief 프로그램을 초기 상태로 되돌리고 LCD 메시지를 초기화합니다.
 */
void reset_program(void) {
    LCD_Clear();                                    // LCD 화면을 지웁니다.
 296:	b2 df       	rcall	.-156    	; 0x1fc <LCD_Clear>
    LCD_pos(0, 0);                                  // 커서를 첫 번째 줄(row 0), 첫 번째 칸(col 0)으로 이동합니다.
 298:	60 e0       	ldi	r22, 0x00	; 0
 29a:	80 e0       	ldi	r24, 0x00	; 0
 29c:	a8 df       	rcall	.-176    	; 0x1ee <LCD_pos>
    LCD_STR((unsigned char*)"Input PassWord");       // "Input PassWord" 메시지를 첫 번째 줄에 출력합니다.
 29e:	84 e1       	ldi	r24, 0x14	; 20
 2a0:	91 e0       	ldi	r25, 0x01	; 1
 2a2:	99 df       	rcall	.-206    	; 0x1d6 <LCD_STR>
    
    current_program_state = PROGRAM_STATE_INPUT_PASSWORD; // 프로그램 상태를 비밀번호 입력 모드로 설정합니다.
 2a4:	10 92 b0 01 	sts	0x01B0, r1	; 0x8001b0 <current_program_state>
    
    LCD_pos(0, 1);                                  // 숫자 입력을 위한 커서를 두 번째 줄(row 1), 첫 번째 칸(col 0)으로 이동합니다.
 2a8:	61 e0       	ldi	r22, 0x01	; 1
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	a0 df       	rcall	.-192    	; 0x1ee <LCD_pos>
    
    password_index = 0;                             // 입력된 비밀번호 인덱스를 0으로 초기화합니다.
 2ae:	10 92 af 01 	sts	0x01AF, r1	; 0x8001af <__data_end+0x1>
 2b2:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <__data_end>
    memset(entered_password, 0, sizeof(entered_password)); // entered_password 버퍼를 모두 0으로 지웁니다.
 2b6:	88 e0       	ldi	r24, 0x08	; 8
 2b8:	e1 eb       	ldi	r30, 0xB1	; 177
 2ba:	f1 e0       	ldi	r31, 0x01	; 1
 2bc:	df 01       	movw	r26, r30
 2be:	1d 92       	st	X+, r1
 2c0:	8a 95       	dec	r24
    led_off();                                      // 풀컬러 LED를 모두 끕니다.
 2c2:	e9 f7       	brne	.-6      	; 0x2be <reset_program+0x28>
 2c4:	df cf       	rjmp	.-66     	; 0x284 <led_off>
 2c6:	08 95       	ret

000002c8 <enter_admin_mode>:

/**
 * @brief 관리자 모드로 진입 시 LCD 메시지 및 상태를 설정합니다.
 */
void enter_admin_mode(void) {
    LCD_Clear();                                    // LCD 화면을 지웁니다.
 2c8:	99 df       	rcall	.-206    	; 0x1fc <LCD_Clear>
    LCD_pos(0, 0);                                  // 커서를 첫 번째 줄(row 0), 첫 번째 칸(col 0)으로 이동합니다.
 2ca:	60 e0       	ldi	r22, 0x00	; 0
 2cc:	80 e0       	ldi	r24, 0x00	; 0
 2ce:	8f df       	rcall	.-226    	; 0x1ee <LCD_pos>
    LCD_STR((unsigned char*)"Admin Mode");          // "Admin Mode" 메시지를 출력합니다.
 2d0:	83 e2       	ldi	r24, 0x23	; 35
 2d2:	91 e0       	ldi	r25, 0x01	; 1
 2d4:	80 df       	rcall	.-256    	; 0x1d6 <LCD_STR>
    LCD_pos(0, 1);                                  // 커서를 두 번째 줄(row 1), 첫 번째 칸(col 0)으로 이동합니다.
 2d6:	61 e0       	ldi	r22, 0x01	; 1
 2d8:	80 e0       	ldi	r24, 0x00	; 0
 2da:	89 df       	rcall	.-238    	; 0x1ee <LCD_pos>
    LCD_STR((unsigned char*)"# for New PWD");       // "# for New PWD" 안내 메시지를 출력합니다.
 2dc:	8e e2       	ldi	r24, 0x2E	; 46
 2de:	91 e0       	ldi	r25, 0x01	; 1
 2e0:	7a df       	rcall	.-268    	; 0x1d6 <LCD_STR>
 2e2:	81 e0       	ldi	r24, 0x01	; 1

    current_program_state = PROGRAM_STATE_ADMIN_MODE; // 프로그램 상태를 관리자 모드로 설정합니다.
 2e4:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <current_program_state>
 2e8:	10 92 af 01 	sts	0x01AF, r1	; 0x8001af <__data_end+0x1>
    
    // 이 모드에서는 비밀번호를 입력받지 않으므로, 입력 버퍼와 인덱스는 초기화 상태로 둡니다.
    password_index = 0;                             
 2ec:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <__data_end>
 2f0:	88 e0       	ldi	r24, 0x08	; 8
    memset(entered_password, 0, sizeof(entered_password)); 
 2f2:	e1 eb       	ldi	r30, 0xB1	; 177
 2f4:	f1 e0       	ldi	r31, 0x01	; 1
 2f6:	df 01       	movw	r26, r30
 2f8:	1d 92       	st	X+, r1
 2fa:	8a 95       	dec	r24
 2fc:	e9 f7       	brne	.-6      	; 0x2f8 <enter_admin_mode+0x30>
 2fe:	08 95       	ret

00000300 <enter_change_password_mode>:
 300:	7d df       	rcall	.-262    	; 0x1fc <LCD_Clear>
/**
 * @brief 새 비밀번호 설정 모드로 진입 시 LCD 메시지 및 상태를 설정합니다.
 */
void enter_change_password_mode(void) {
    LCD_Clear();                                    // LCD 화면을 지웁니다.
    LCD_pos(0, 0);                                  // 커서를 첫 번째 줄(row 0), 첫 번째 칸(col 0)으로 이동합니다.
 302:	60 e0       	ldi	r22, 0x00	; 0
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	73 df       	rcall	.-282    	; 0x1ee <LCD_pos>
    LCD_STR((unsigned char*)"Enter New PWD");       // "Enter New PWD" 메시지를 출력합니다.
 308:	8c e3       	ldi	r24, 0x3C	; 60
 30a:	91 e0       	ldi	r25, 0x01	; 1
 30c:	64 df       	rcall	.-312    	; 0x1d6 <LCD_STR>
    LCD_pos(0, 1);                                  // 새 비밀번호 입력을 위한 커서를 두 번째 줄(row 1), 첫 번째 칸(col 0)으로 이동합니다.
 30e:	61 e0       	ldi	r22, 0x01	; 1
 310:	80 e0       	ldi	r24, 0x00	; 0
 312:	6d df       	rcall	.-294    	; 0x1ee <LCD_pos>
 314:	82 e0       	ldi	r24, 0x02	; 2
    
    current_program_state = PROGRAM_STATE_CHANGE_PASSWORD; // 프로그램 상태를 비밀번호 변경 모드로 설정합니다.
 316:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <current_program_state>
 31a:	10 92 af 01 	sts	0x01AF, r1	; 0x8001af <__data_end+0x1>
    
    password_index = 0;                             // 입력된 비밀번호 인덱스를 0으로 초기화합니다.
 31e:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <__data_end>
 322:	88 e0       	ldi	r24, 0x08	; 8
    memset(entered_password, 0, sizeof(entered_password)); // entered_password 버퍼를 지웁니다.
 324:	e1 eb       	ldi	r30, 0xB1	; 177
 326:	f1 e0       	ldi	r31, 0x01	; 1
 328:	df 01       	movw	r26, r30
 32a:	1d 92       	st	X+, r1
 32c:	8a 95       	dec	r24
 32e:	e9 f7       	brne	.-6      	; 0x32a <enter_change_password_mode+0x2a>
 330:	08 95       	ret

00000332 <main>:
 332:	87 e0       	ldi	r24, 0x07	; 7
 * @brief 메인 함수: 프로그램의 시작점이며 무한 루프를 통해 시스템을 운영합니다.
 */
int main(void) {
    // 하드웨어 포트 방향 설정 (각 모듈의 초기화 함수에서 대부분 처리됩니다.)
    // LED (PORTE)는 main에서 직접 DDR 설정
    DDRE = 0x07; // PORTE의 PE0, PE1, PE2 핀을 출력으로 설정합니다 (풀컬러 LED 제어용).
 334:	82 b9       	out	0x02, r24	; 2

    // 각 모듈 (LCD, 키패드, LED) 초기화
    Port_Init();    // LCD 포트 초기화 (lcd.c에 정의되어 있음)
 336:	16 df       	rcall	.-468    	; 0x164 <Port_Init>
    LCD_Init();     // LCD 컨트롤러 초기화 (lcd.c에 정의되어 있음)
 338:	6a df       	rcall	.-300    	; 0x20e <LCD_Init>
    Keypad_Init();  // 키패드 포트 초기화 (keypad.c에 정의되어 있음)
 33a:	c6 de       	rcall	.-628    	; 0xc8 <Keypad_Init>
    led_init();     // 풀컬러 LED 초기화 (led.c에 정의되어 있음)
 33c:	a7 df       	rcall	.-178    	; 0x28c <led_init>

    sei(); // Global Interrupt Enable (필요하다면 활성화, 여기서는 폴링 방식이므로 필수 아님)
 33e:	78 94       	sei

    reset_program(); // 프로그램 시작 시 초기 상태로 설정합니다.
 340:	aa df       	rcall	.-172    	; 0x296 <reset_program>
 342:	c8 de       	rcall	.-624    	; 0xd4 <keypad_get_char>

    // 메인 무한 루프
    while (1) {
        char key = keypad_get_char(); // 키패드에서 눌린 키 값을 읽어옵니다. (없으면 '\0' 반환)
 344:	c8 2f       	mov	r28, r24
 346:	88 23       	and	r24, r24
 348:	e1 f3       	breq	.-8      	; 0x342 <main+0x10>

        if (key != '\0') { // 키가 입력되었다면
 34a:	2f ef       	ldi	r18, 0xFF	; 255
 34c:	8f e3       	ldi	r24, 0x3F	; 63
 34e:	92 e0       	ldi	r25, 0x02	; 2
 350:	21 50       	subi	r18, 0x01	; 1
 352:	80 40       	sbci	r24, 0x00	; 0
 354:	90 40       	sbci	r25, 0x00	; 0
 356:	e1 f7       	brne	.-8      	; 0x350 <main+0x1e>
 358:	00 c0       	rjmp	.+0      	; 0x35a <main+0x28>
 35a:	00 00       	nop
 35c:	bb de       	rcall	.-650    	; 0xd4 <keypad_get_char>
            // 키 디바운싱: 키 눌림이 여러 번 감지되는 것을 방지합니다.
            _delay_ms(50); // 키 눌림 감지 후 짧게 대기하여 채터링(chattering)을 무시합니다.
            while (keypad_get_char() != '\0'); // 키가 떼어질 때까지 계속 키패드를 읽어 대기합니다.
 35e:	81 11       	cpse	r24, r1
 360:	fd cf       	rjmp	.-6      	; 0x35c <main+0x2a>
 362:	2f ef       	ldi	r18, 0xFF	; 255
 364:	8f e3       	ldi	r24, 0x3F	; 63
 366:	92 e0       	ldi	r25, 0x02	; 2
 368:	21 50       	subi	r18, 0x01	; 1
 36a:	80 40       	sbci	r24, 0x00	; 0
 36c:	90 40       	sbci	r25, 0x00	; 0
 36e:	e1 f7       	brne	.-8      	; 0x368 <main+0x36>
 370:	00 c0       	rjmp	.+0      	; 0x372 <main+0x40>
 372:	00 00       	nop
 374:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <current_program_state>
            _delay_ms(50); // 키가 완전히 떼어진 것을 확인 후 짧게 대기합니다.

            // 현재 프로그램 상태에 따라 다른 동작을 수행합니다 (상태 머신).
            switch (current_program_state) {
 378:	81 30       	cpi	r24, 0x01	; 1
 37a:	09 f4       	brne	.+2      	; 0x37e <main+0x4c>
 37c:	df c0       	rjmp	.+446    	; 0x53c <__LOCK_REGION_LENGTH__+0x13c>
 37e:	20 f0       	brcs	.+8      	; 0x388 <main+0x56>
 380:	82 30       	cpi	r24, 0x02	; 2
 382:	09 f4       	brne	.+2      	; 0x386 <main+0x54>
 384:	f9 c0       	rjmp	.+498    	; 0x578 <__LOCK_REGION_LENGTH__+0x178>
 386:	dd cf       	rjmp	.-70     	; 0x342 <main+0x10>
 388:	ca 32       	cpi	r28, 0x2A	; 42
 38a:	c9 f4       	brne	.+50     	; 0x3be <main+0x8c>
                case PROGRAM_STATE_INPUT_PASSWORD:
                    // '비밀번호 입력 대기' 상태의 로직
                    if (key == '*') { // '*' 키는 마지막 입력 지우기 기능으로 사용합니다.
 38c:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
                        if (password_index > 0) { // 입력된 문자가 있다면
 390:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 394:	18 16       	cp	r1, r24
 396:	19 06       	cpc	r1, r25
 398:	a4 f6       	brge	.-88     	; 0x342 <main+0x10>
 39a:	01 97       	sbiw	r24, 0x01	; 1
 39c:	90 93 af 01 	sts	0x01AF, r25	; 0x8001af <__data_end+0x1>
                            password_index--;                      // 인덱스를 줄입니다.
 3a0:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <__data_end>
 3a4:	fc 01       	movw	r30, r24
                            entered_password[password_index] = '\0'; // 해당 위치의 문자를 지웁니다.
 3a6:	ef 54       	subi	r30, 0x4F	; 79
 3a8:	fe 4f       	sbci	r31, 0xFE	; 254
 3aa:	10 82       	st	Z, r1
                            LCD_pos(password_index, 1);            // LCD 커서를 지울 위치로 이동합니다.
 3ac:	61 e0       	ldi	r22, 0x01	; 1
 3ae:	1f df       	rcall	.-450    	; 0x1ee <LCD_pos>
                            LCD_CHAR(' ');                         // 공백을 출력하여 문자를 지운 것처럼 보입니다.
 3b0:	80 e2       	ldi	r24, 0x20	; 32
 3b2:	0a df       	rcall	.-492    	; 0x1c8 <LCD_CHAR>
 3b4:	61 e0       	ldi	r22, 0x01	; 1
                            LCD_pos(password_index, 1);            // 커서를 다시 지운 위치로 돌려놓습니다.
 3b6:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
 3ba:	19 df       	rcall	.-462    	; 0x1ee <LCD_pos>
 3bc:	c2 cf       	rjmp	.-124    	; 0x342 <main+0x10>
 3be:	c3 32       	cpi	r28, 0x23	; 35
 3c0:	09 f0       	breq	.+2      	; 0x3c4 <main+0x92>
                        }
                    } else if (key == '#') { // '#' 키는 입력 완료 기능으로 사용합니다.
 3c2:	a0 c0       	rjmp	.+320    	; 0x504 <__LOCK_REGION_LENGTH__+0x104>
 3c4:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
                        // 사용자가 입력한 비밀번호의 길이에 따라 일반 비밀번호 또는 관리자 비밀번호를 확인합니다.
                        if (password_index == MAX_PASSWORD_LENGTH) { // 입력된 길이가 일반 비밀번호 길이(7자리)와 같다면
 3c8:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 3cc:	87 30       	cpi	r24, 0x07	; 7
 3ce:	91 05       	cpc	r25, r1
 3d0:	09 f0       	breq	.+2      	; 0x3d4 <main+0xa2>
 3d2:	45 c0       	rjmp	.+138    	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
                            // 입력된 비밀번호와 저장된 비밀번호(stored_password)를 비교합니다.
                            if (strcmp(entered_password, (char*)stored_password) == 0) { // 비밀번호가 일치한다면 (정답)
 3d4:	60 e0       	ldi	r22, 0x00	; 0
 3d6:	71 e0       	ldi	r23, 0x01	; 1
 3d8:	81 eb       	ldi	r24, 0xB1	; 177
 3da:	91 e0       	ldi	r25, 0x01	; 1
 3dc:	43 d1       	rcall	.+646    	; 0x664 <strcmp>
                                LCD_Clear();                                // LCD를 지웁니다.
 3de:	89 2b       	or	r24, r25
 3e0:	f9 f4       	brne	.+62     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
                                LCD_pos(0, 0);                              // 커서를 첫 줄로 이동합니다.
 3e2:	0c df       	rcall	.-488    	; 0x1fc <LCD_Clear>
 3e4:	60 e0       	ldi	r22, 0x00	; 0
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	02 df       	rcall	.-508    	; 0x1ee <LCD_pos>
                                LCD_STR((unsigned char*)"OPEN");            // "OPEN" 메시지를 출력합니다.
 3ea:	8a e4       	ldi	r24, 0x4A	; 74
 3ec:	91 e0       	ldi	r25, 0x01	; 1
 3ee:	f3 de       	rcall	.-538    	; 0x1d6 <LCD_STR>
                                led_set_color(LED_GREEN);                   // 풀컬러 LED를 초록색으로 켭니다.
 3f0:	82 e0       	ldi	r24, 0x02	; 2
 3f2:	35 df       	rcall	.-406    	; 0x25e <led_set_color>
 3f4:	2f ef       	ldi	r18, 0xFF	; 255
 3f6:	8f ef       	ldi	r24, 0xFF	; 255
 3f8:	90 ee       	ldi	r25, 0xE0	; 224
 3fa:	21 50       	subi	r18, 0x01	; 1
 3fc:	80 40       	sbci	r24, 0x00	; 0
 3fe:	90 40       	sbci	r25, 0x00	; 0
 400:	e1 f7       	brne	.-8      	; 0x3fa <main+0xc8>
 402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
                                _delay_ms(5000);                            // 5초 동안 유지합니다.
                                led_set_color(LED_YELLOW);                  // LED를 노란색으로 변경합니다.
 404:	00 00       	nop
 406:	83 e0       	ldi	r24, 0x03	; 3
 408:	2a df       	rcall	.-428    	; 0x25e <led_set_color>
 40a:	2f ef       	ldi	r18, 0xFF	; 255
 40c:	8f ef       	ldi	r24, 0xFF	; 255
 40e:	9c e2       	ldi	r25, 0x2C	; 44
 410:	21 50       	subi	r18, 0x01	; 1
 412:	80 40       	sbci	r24, 0x00	; 0
 414:	90 40       	sbci	r25, 0x00	; 0
                                _delay_ms(1000);                            // 1초 동안 유지합니다 (다음 루프를 위해 잠시).
                                reset_program();                            // 프로그램 상태를 초기화합니다.
 416:	e1 f7       	brne	.-8      	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 418:	00 c0       	rjmp	.+0      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
 41a:	00 00       	nop
                            } else { // 비밀번호가 일치하지 않는다면 (오답)
                                LCD_Clear();                                // LCD를 지웁니다.
 41c:	3c df       	rcall	.-392    	; 0x296 <reset_program>
 41e:	91 cf       	rjmp	.-222    	; 0x342 <main+0x10>
                                LCD_pos(0, 0);                              // 커서를 첫 줄로 이동합니다.
 420:	ed de       	rcall	.-550    	; 0x1fc <LCD_Clear>
 422:	60 e0       	ldi	r22, 0x00	; 0
 424:	80 e0       	ldi	r24, 0x00	; 0
                                LCD_STR((unsigned char*)"Not PassWord");    // "Not PassWord" 메시지를 출력합니다.
 426:	e3 de       	rcall	.-570    	; 0x1ee <LCD_pos>
 428:	8f e4       	ldi	r24, 0x4F	; 79
 42a:	91 e0       	ldi	r25, 0x01	; 1
 42c:	d4 de       	rcall	.-600    	; 0x1d6 <LCD_STR>
                                led_set_color(LED_RED);                     // 풀컬러 LED를 빨간색으로 켭니다.
 42e:	81 e0       	ldi	r24, 0x01	; 1
 430:	16 df       	rcall	.-468    	; 0x25e <led_set_color>
 432:	2f ef       	ldi	r18, 0xFF	; 255
 434:	8f ef       	ldi	r24, 0xFF	; 255
 436:	99 e5       	ldi	r25, 0x59	; 89
 438:	21 50       	subi	r18, 0x01	; 1
 43a:	80 40       	sbci	r24, 0x00	; 0
 43c:	90 40       	sbci	r25, 0x00	; 0
 43e:	e1 f7       	brne	.-8      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
 440:	00 c0       	rjmp	.+0      	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
                                _delay_ms(2000);                            // 2초 동안 유지합니다.
                                led_set_color(LED_YELLOW);                  // LED를 노란색으로 변경합니다.
 442:	00 00       	nop
 444:	83 e0       	ldi	r24, 0x03	; 3
 446:	0b df       	rcall	.-490    	; 0x25e <led_set_color>
 448:	2f ef       	ldi	r18, 0xFF	; 255
 44a:	8f ef       	ldi	r24, 0xFF	; 255
 44c:	9c e2       	ldi	r25, 0x2C	; 44
 44e:	21 50       	subi	r18, 0x01	; 1
 450:	80 40       	sbci	r24, 0x00	; 0
                                _delay_ms(1000);                            // 1초 동안 유지합니다.
                                reset_program();                            // 프로그램 상태를 초기화합니다.
 452:	90 40       	sbci	r25, 0x00	; 0
 454:	e1 f7       	brne	.-8      	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
 456:	00 c0       	rjmp	.+0      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
                            }
                        } 
                        // 입력된 길이가 관리자 비밀번호 길이(5자리)와 같다면
                        else if (password_index == ADMIN_PASSWORD_LENGTH) {
 458:	00 00       	nop
 45a:	1d df       	rcall	.-454    	; 0x296 <reset_program>
                             // 입력된 비밀번호와 관리자 비밀번호(ADMIN_PASSWORD)를 비교합니다.
                             if (strcmp(entered_password, ADMIN_PASSWORD) == 0) { // 관리자 비밀번호가 일치한다면
 45c:	72 cf       	rjmp	.-284    	; 0x342 <main+0x10>
 45e:	05 97       	sbiw	r24, 0x05	; 5
 460:	41 f5       	brne	.+80     	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
 462:	6c e5       	ldi	r22, 0x5C	; 92
 464:	71 e0       	ldi	r23, 0x01	; 1
 466:	81 eb       	ldi	r24, 0xB1	; 177
 468:	91 e0       	ldi	r25, 0x01	; 1
                                enter_admin_mode();                             // 관리자 모드로 진입합니다.
 46a:	fc d0       	rcall	.+504    	; 0x664 <strcmp>
 46c:	89 2b       	or	r24, r25
 46e:	11 f4       	brne	.+4      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
                            } else { // 관리자 비밀번호가 일치하지 않는다면
                                LCD_Clear();                                    // LCD를 지웁니다.
 470:	2b df       	rcall	.-426    	; 0x2c8 <enter_admin_mode>
 472:	67 cf       	rjmp	.-306    	; 0x342 <main+0x10>
                                LCD_pos(0, 0);                                  // 커서를 첫 줄로 이동합니다.
 474:	c3 de       	rcall	.-634    	; 0x1fc <LCD_Clear>
 476:	60 e0       	ldi	r22, 0x00	; 0
 478:	80 e0       	ldi	r24, 0x00	; 0
                                LCD_STR((unsigned char*)"Not Admin PWD");       // "Not Admin PWD" 메시지를 출력합니다.
 47a:	b9 de       	rcall	.-654    	; 0x1ee <LCD_pos>
 47c:	82 e6       	ldi	r24, 0x62	; 98
 47e:	91 e0       	ldi	r25, 0x01	; 1
                                led_set_color(LED_RED);                         // 풀컬러 LED를 빨간색으로 켭니다.
 480:	aa de       	rcall	.-684    	; 0x1d6 <LCD_STR>
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	ec de       	rcall	.-552    	; 0x25e <led_set_color>
 486:	2f ef       	ldi	r18, 0xFF	; 255
 488:	8f ef       	ldi	r24, 0xFF	; 255
 48a:	99 e5       	ldi	r25, 0x59	; 89
 48c:	21 50       	subi	r18, 0x01	; 1
 48e:	80 40       	sbci	r24, 0x00	; 0
 490:	90 40       	sbci	r25, 0x00	; 0
                                _delay_ms(2000);                                // 2초 동안 유지합니다.
                                led_set_color(LED_YELLOW);                      // LED를 노란색으로 변경합니다.
 492:	e1 f7       	brne	.-8      	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
 494:	00 c0       	rjmp	.+0      	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
 496:	00 00       	nop
 498:	83 e0       	ldi	r24, 0x03	; 3
 49a:	e1 de       	rcall	.-574    	; 0x25e <led_set_color>
 49c:	2f ef       	ldi	r18, 0xFF	; 255
 49e:	8f ef       	ldi	r24, 0xFF	; 255
 4a0:	9c e2       	ldi	r25, 0x2C	; 44
 4a2:	21 50       	subi	r18, 0x01	; 1
 4a4:	80 40       	sbci	r24, 0x00	; 0
 4a6:	90 40       	sbci	r25, 0x00	; 0
                                _delay_ms(1000);                                // 1초 동안 유지합니다.
                                reset_program();                                // 프로그램 상태를 초기화합니다.
 4a8:	e1 f7       	brne	.-8      	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
 4aa:	00 c0       	rjmp	.+0      	; 0x4ac <__LOCK_REGION_LENGTH__+0xac>
 4ac:	00 00       	nop
                            }
                        }
                        else { // 비밀번호 길이가 조건에 맞지 않을 때 (7자리 또는 5자리 요구)
                             LCD_pos(0, 1);                                    // 커서를 두 번째 줄로 이동합니다.
 4ae:	f3 de       	rcall	.-538    	; 0x296 <reset_program>
 4b0:	48 cf       	rjmp	.-368    	; 0x342 <main+0x10>
 4b2:	61 e0       	ldi	r22, 0x01	; 1
                             LCD_STR((unsigned char*)"         ");             // 기존 입력 내용을 지우기 위해 공백을 출력합니다.
 4b4:	80 e0       	ldi	r24, 0x00	; 0
 4b6:	9b de       	rcall	.-714    	; 0x1ee <LCD_pos>
 4b8:	80 e7       	ldi	r24, 0x70	; 112
 4ba:	91 e0       	ldi	r25, 0x01	; 1
                             LCD_pos(0, 1);                                    // 커서를 다시 두 번째 줄 시작 위치로 이동합니다.
 4bc:	8c de       	rcall	.-744    	; 0x1d6 <LCD_STR>
 4be:	61 e0       	ldi	r22, 0x01	; 1
 4c0:	80 e0       	ldi	r24, 0x00	; 0
 4c2:	95 de       	rcall	.-726    	; 0x1ee <LCD_pos>
                             LCD_STR((unsigned char*)"7 or 5 digits");         // "7 or 5 digits" 안내 메시지를 출력합니다.
 4c4:	8a e7       	ldi	r24, 0x7A	; 122
 4c6:	91 e0       	ldi	r25, 0x01	; 1
 4c8:	86 de       	rcall	.-756    	; 0x1d6 <LCD_STR>
 4ca:	2f ef       	ldi	r18, 0xFF	; 255
 4cc:	8f ef       	ldi	r24, 0xFF	; 255
 4ce:	9c e2       	ldi	r25, 0x2C	; 44
 4d0:	21 50       	subi	r18, 0x01	; 1
 4d2:	80 40       	sbci	r24, 0x00	; 0
 4d4:	90 40       	sbci	r25, 0x00	; 0
 4d6:	e1 f7       	brne	.-8      	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
 4d8:	00 c0       	rjmp	.+0      	; 0x4da <__LOCK_REGION_LENGTH__+0xda>
 4da:	00 00       	nop
                             _delay_ms(1000);                                  // 1초 동안 메시지를 보여줍니다.
                             LCD_pos(0, 1);                                    // 커서를 다시 입력 위치로 이동합니다.
 4dc:	61 e0       	ldi	r22, 0x01	; 1
 4de:	80 e0       	ldi	r24, 0x00	; 0
 4e0:	86 de       	rcall	.-756    	; 0x1ee <LCD_pos>
 4e2:	c0 e0       	ldi	r28, 0x00	; 0
                             // 이전에 입력된 숫자를 다시 표시하여 사용자가 이어서 입력할 수 있도록 합니다.
                             for(int i=0; i<password_index; i++) {
 4e4:	d0 e0       	ldi	r29, 0x00	; 0
 4e6:	06 c0       	rjmp	.+12     	; 0x4f4 <__LOCK_REGION_LENGTH__+0xf4>
 4e8:	fe 01       	movw	r30, r28
                                LCD_CHAR((unsigned char)entered_password[i]);
 4ea:	ef 54       	subi	r30, 0x4F	; 79
 4ec:	fe 4f       	sbci	r31, 0xFE	; 254
 4ee:	80 81       	ld	r24, Z
 4f0:	6b de       	rcall	.-810    	; 0x1c8 <LCD_CHAR>
 4f2:	21 96       	adiw	r28, 0x01	; 1
 4f4:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
                             LCD_pos(0, 1);                                    // 커서를 다시 두 번째 줄 시작 위치로 이동합니다.
                             LCD_STR((unsigned char*)"7 or 5 digits");         // "7 or 5 digits" 안내 메시지를 출력합니다.
                             _delay_ms(1000);                                  // 1초 동안 메시지를 보여줍니다.
                             LCD_pos(0, 1);                                    // 커서를 다시 입력 위치로 이동합니다.
                             // 이전에 입력된 숫자를 다시 표시하여 사용자가 이어서 입력할 수 있도록 합니다.
                             for(int i=0; i<password_index; i++) {
 4f8:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 4fc:	c8 17       	cp	r28, r24
 4fe:	d9 07       	cpc	r29, r25
 500:	9c f3       	brlt	.-26     	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
 502:	1f cf       	rjmp	.-450    	; 0x342 <main+0x10>
                                LCD_CHAR((unsigned char)entered_password[i]);
                             }
                        }
                    } else { // 숫자 키가 입력되었을 때
                        if (password_index < MAX_PASSWORD_LENGTH) { // 현재 입력 길이가 최대 길이(7자리) 미만인 경우에만 입력 받습니다.
 504:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
 508:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 50c:	87 30       	cpi	r24, 0x07	; 7
 50e:	91 05       	cpc	r25, r1
                            entered_password[password_index] = key;  // 입력된 키를 버퍼에 저장합니다.
 510:	0c f0       	brlt	.+2      	; 0x514 <__LOCK_REGION_LENGTH__+0x114>
 512:	17 cf       	rjmp	.-466    	; 0x342 <main+0x10>
 514:	fc 01       	movw	r30, r24
 516:	ef 54       	subi	r30, 0x4F	; 79
                            LCD_CHAR((unsigned char)key);            // LCD 두 번째 줄에 해당 숫자를 출력합니다.
 518:	fe 4f       	sbci	r31, 0xFE	; 254
 51a:	c0 83       	st	Z, r28
 51c:	8c 2f       	mov	r24, r28
                            password_index++;                        // 인덱스를 증가시킵니다.
 51e:	54 de       	rcall	.-856    	; 0x1c8 <LCD_CHAR>
 520:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
 524:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 528:	01 96       	adiw	r24, 0x01	; 1
 52a:	90 93 af 01 	sts	0x01AF, r25	; 0x8001af <__data_end+0x1>
                            entered_password[password_index] = '\0'; // 다음 입력을 위해 널 종료 문자를 추가합니다.
 52e:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <__data_end>
 532:	fc 01       	movw	r30, r24
 534:	ef 54       	subi	r30, 0x4F	; 79
                    }
                    break; // PROGRAM_STATE_INPUT_PASSWORD 케이스 종료

                case PROGRAM_STATE_ADMIN_MODE:
                    // '관리자 모드' 상태의 로직
                    if (key == '#') { // '#' 키를 누르면 '새 비밀번호 설정' 모드로 진입합니다.
 536:	fe 4f       	sbci	r31, 0xFE	; 254
 538:	10 82       	st	Z, r1
                        enter_change_password_mode();
 53a:	03 cf       	rjmp	.-506    	; 0x342 <main+0x10>
 53c:	c3 32       	cpi	r28, 0x23	; 35
 53e:	11 f4       	brne	.+4      	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
                    } else if (key == '*') { // '*' 키를 누르면 관리자 모드를 종료하고 초기 상태로 돌아갑니다.
 540:	df de       	rcall	.-578    	; 0x300 <enter_change_password_mode>
 542:	ff ce       	rjmp	.-514    	; 0x342 <main+0x10>
                        reset_program();
 544:	ca 32       	cpi	r28, 0x2A	; 42
 546:	11 f4       	brne	.+4      	; 0x54c <__LOCK_REGION_LENGTH__+0x14c>
                    } else { // 그 외의 키가 입력되면 잘못된 키임을 알립니다.
                        LCD_pos(0, 1);                             // 커서를 두 번째 줄로 이동합니다.
 548:	a6 de       	rcall	.-692    	; 0x296 <reset_program>
 54a:	fb ce       	rjmp	.-522    	; 0x342 <main+0x10>
 54c:	61 e0       	ldi	r22, 0x01	; 1
                        LCD_STR((unsigned char*)"Invalid Key");   // "Invalid Key" 메시지를 출력합니다.
 54e:	80 e0       	ldi	r24, 0x00	; 0
 550:	4e de       	rcall	.-868    	; 0x1ee <LCD_pos>
 552:	88 e8       	ldi	r24, 0x88	; 136
 554:	91 e0       	ldi	r25, 0x01	; 1
 556:	3f de       	rcall	.-898    	; 0x1d6 <LCD_STR>
 558:	2f ef       	ldi	r18, 0xFF	; 255
 55a:	8f ef       	ldi	r24, 0xFF	; 255
 55c:	9c e2       	ldi	r25, 0x2C	; 44
 55e:	21 50       	subi	r18, 0x01	; 1
 560:	80 40       	sbci	r24, 0x00	; 0
 562:	90 40       	sbci	r25, 0x00	; 0
                        _delay_ms(1000);                           // 1초 동안 메시지를 보여줍니다.
                        LCD_pos(0, 1);                             // 커서를 다시 두 번째 줄 시작 위치로 이동합니다.
 564:	e1 f7       	brne	.-8      	; 0x55e <__LOCK_REGION_LENGTH__+0x15e>
 566:	00 c0       	rjmp	.+0      	; 0x568 <__LOCK_REGION_LENGTH__+0x168>
 568:	00 00       	nop
                        LCD_STR((unsigned char*)"# for New PWD"); // 원래 안내 메시지를 다시 출력합니다.
 56a:	61 e0       	ldi	r22, 0x01	; 1
 56c:	80 e0       	ldi	r24, 0x00	; 0
 56e:	3f de       	rcall	.-898    	; 0x1ee <LCD_pos>
 570:	8e e2       	ldi	r24, 0x2E	; 46
 572:	91 e0       	ldi	r25, 0x01	; 1
                    }
                    break; // PROGRAM_STATE_ADMIN_MODE 케이스 종료

                case PROGRAM_STATE_CHANGE_PASSWORD:
                    // '새 비밀번호 설정' 상태의 로직
                    if (key == '*') { // '*' 키를 누르면 비밀번호 변경을 취소하고 초기 상태로 돌아갑니다.
 574:	30 de       	rcall	.-928    	; 0x1d6 <LCD_STR>
 576:	e5 ce       	rjmp	.-566    	; 0x342 <main+0x10>
                        reset_program();
 578:	ca 32       	cpi	r28, 0x2A	; 42
 57a:	11 f4       	brne	.+4      	; 0x580 <__LOCK_REGION_LENGTH__+0x180>
                    } else if (key == '#') { // '#' 키를 누르면 새 비밀번호 입력을 완료합니다.
 57c:	8c de       	rcall	.-744    	; 0x296 <reset_program>
 57e:	e1 ce       	rjmp	.-574    	; 0x342 <main+0x10>
                        if (password_index == MAX_PASSWORD_LENGTH) { // 새 비밀번호가 7자리로 모두 입력되었다면
 580:	c3 32       	cpi	r28, 0x23	; 35
 582:	09 f0       	breq	.+2      	; 0x586 <__LOCK_REGION_LENGTH__+0x186>
 584:	53 c0       	rjmp	.+166    	; 0x62c <__LOCK_REGION_LENGTH__+0x22c>
 586:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
                            // entered_password에 있는 새 비밀번호를 stored_password로 복사합니다.
                            strcpy((char*)stored_password, entered_password); 
 58a:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 58e:	07 97       	sbiw	r24, 0x07	; 7
 590:	21 f5       	brne	.+72     	; 0x5da <__LOCK_REGION_LENGTH__+0x1da>
 592:	61 eb       	ldi	r22, 0xB1	; 177
                            LCD_Clear();                                // LCD를 지웁니다.
 594:	71 e0       	ldi	r23, 0x01	; 1
 596:	80 e0       	ldi	r24, 0x00	; 0
                            LCD_pos(0, 0);                              // 커서를 첫 줄로 이동합니다.
 598:	91 e0       	ldi	r25, 0x01	; 1
 59a:	6d d0       	rcall	.+218    	; 0x676 <strcpy>
 59c:	2f de       	rcall	.-930    	; 0x1fc <LCD_Clear>
 59e:	60 e0       	ldi	r22, 0x00	; 0
                            LCD_STR((unsigned char*)"PWD Changed!");    // "PWD Changed!" 메시지를 출력합니다.
 5a0:	80 e0       	ldi	r24, 0x00	; 0
 5a2:	25 de       	rcall	.-950    	; 0x1ee <LCD_pos>
 5a4:	84 e9       	ldi	r24, 0x94	; 148
                            led_set_color(LED_GREEN);                   // 풀컬러 LED를 초록색으로 켭니다.
 5a6:	91 e0       	ldi	r25, 0x01	; 1
 5a8:	16 de       	rcall	.-980    	; 0x1d6 <LCD_STR>
 5aa:	82 e0       	ldi	r24, 0x02	; 2
 5ac:	58 de       	rcall	.-848    	; 0x25e <led_set_color>
 5ae:	2f ef       	ldi	r18, 0xFF	; 255
 5b0:	8f ef       	ldi	r24, 0xFF	; 255
 5b2:	96 e8       	ldi	r25, 0x86	; 134
 5b4:	21 50       	subi	r18, 0x01	; 1
 5b6:	80 40       	sbci	r24, 0x00	; 0
 5b8:	90 40       	sbci	r25, 0x00	; 0
 5ba:	e1 f7       	brne	.-8      	; 0x5b4 <__LOCK_REGION_LENGTH__+0x1b4>
                            _delay_ms(3000);                            // 3초 동안 유지합니다.
                            led_set_color(LED_YELLOW);                  // LED를 노란색으로 변경합니다.
 5bc:	00 c0       	rjmp	.+0      	; 0x5be <__LOCK_REGION_LENGTH__+0x1be>
 5be:	00 00       	nop
 5c0:	83 e0       	ldi	r24, 0x03	; 3
 5c2:	4d de       	rcall	.-870    	; 0x25e <led_set_color>
 5c4:	2f ef       	ldi	r18, 0xFF	; 255
 5c6:	8f ef       	ldi	r24, 0xFF	; 255
 5c8:	9c e2       	ldi	r25, 0x2C	; 44
 5ca:	21 50       	subi	r18, 0x01	; 1
 5cc:	80 40       	sbci	r24, 0x00	; 0
 5ce:	90 40       	sbci	r25, 0x00	; 0
 5d0:	e1 f7       	brne	.-8      	; 0x5ca <__LOCK_REGION_LENGTH__+0x1ca>
 5d2:	00 c0       	rjmp	.+0      	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
                            _delay_ms(1000);                            // 1초 동안 유지합니다.
                            reset_program();                            // 프로그램 상태를 초기화합니다.
 5d4:	00 00       	nop
 5d6:	5f de       	rcall	.-834    	; 0x296 <reset_program>
 5d8:	b4 ce       	rjmp	.-664    	; 0x342 <main+0x10>
                        } else { // 7자리가 채워지지 않았을 때
                            LCD_pos(0, 1);                             // 커서를 두 번째 줄로 이동합니다.
 5da:	61 e0       	ldi	r22, 0x01	; 1
 5dc:	80 e0       	ldi	r24, 0x00	; 0
 5de:	07 de       	rcall	.-1010   	; 0x1ee <LCD_pos>
                            LCD_STR((unsigned char*)"         ");       // 기존 입력 내용을 지우기 위해 공백을 출력합니다.
 5e0:	80 e7       	ldi	r24, 0x70	; 112
 5e2:	91 e0       	ldi	r25, 0x01	; 1
 5e4:	f8 dd       	rcall	.-1040   	; 0x1d6 <LCD_STR>
 5e6:	61 e0       	ldi	r22, 0x01	; 1
                            LCD_pos(0, 1);                             // 커서를 다시 두 번째 줄 시작 위치로 이동합니다.
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	01 de       	rcall	.-1022   	; 0x1ee <LCD_pos>
 5ec:	81 ea       	ldi	r24, 0xA1	; 161
 5ee:	91 e0       	ldi	r25, 0x01	; 1
                            LCD_STR((unsigned char*)"7 digits Req");  // "7 digits Req" 안내 메시지를 출력합니다.
 5f0:	f2 dd       	rcall	.-1052   	; 0x1d6 <LCD_STR>
 5f2:	2f ef       	ldi	r18, 0xFF	; 255
 5f4:	8f ef       	ldi	r24, 0xFF	; 255
 5f6:	9c e2       	ldi	r25, 0x2C	; 44
 5f8:	21 50       	subi	r18, 0x01	; 1
 5fa:	80 40       	sbci	r24, 0x00	; 0
 5fc:	90 40       	sbci	r25, 0x00	; 0
 5fe:	e1 f7       	brne	.-8      	; 0x5f8 <__LOCK_REGION_LENGTH__+0x1f8>
 600:	00 c0       	rjmp	.+0      	; 0x602 <__LOCK_REGION_LENGTH__+0x202>
 602:	00 00       	nop
 604:	61 e0       	ldi	r22, 0x01	; 1
 606:	80 e0       	ldi	r24, 0x00	; 0
 608:	f2 dd       	rcall	.-1052   	; 0x1ee <LCD_pos>
                            _delay_ms(1000);                           // 1초 동안 메시지를 보여줍니다.
                            LCD_pos(0, 1);                             // 커서를 다시 입력 위치로 이동합니다.
 60a:	c0 e0       	ldi	r28, 0x00	; 0
 60c:	d0 e0       	ldi	r29, 0x00	; 0
 60e:	06 c0       	rjmp	.+12     	; 0x61c <__LOCK_REGION_LENGTH__+0x21c>
 610:	fe 01       	movw	r30, r28
                            // 이전에 입력된 숫자를 다시 표시하여 사용자가 이어서 입력할 수 있도록 합니다.
                            for(int i=0; i<password_index; i++) {
 612:	ef 54       	subi	r30, 0x4F	; 79
 614:	fe 4f       	sbci	r31, 0xFE	; 254
 616:	80 81       	ld	r24, Z
                                LCD_CHAR((unsigned char)entered_password[i]);
 618:	d7 dd       	rcall	.-1106   	; 0x1c8 <LCD_CHAR>
 61a:	21 96       	adiw	r28, 0x01	; 1
 61c:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
 620:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
                            LCD_pos(0, 1);                             // 커서를 다시 두 번째 줄 시작 위치로 이동합니다.
                            LCD_STR((unsigned char*)"7 digits Req");  // "7 digits Req" 안내 메시지를 출력합니다.
                            _delay_ms(1000);                           // 1초 동안 메시지를 보여줍니다.
                            LCD_pos(0, 1);                             // 커서를 다시 입력 위치로 이동합니다.
                            // 이전에 입력된 숫자를 다시 표시하여 사용자가 이어서 입력할 수 있도록 합니다.
                            for(int i=0; i<password_index; i++) {
 624:	c8 17       	cp	r28, r24
 626:	d9 07       	cpc	r29, r25
 628:	9c f3       	brlt	.-26     	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
 62a:	8b ce       	rjmp	.-746    	; 0x342 <main+0x10>
 62c:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
 630:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
 634:	87 30       	cpi	r24, 0x07	; 7
                                LCD_CHAR((unsigned char)entered_password[i]);
                            }
                        }
                    } else { // 숫자 키가 입력되었을 때
                        if (password_index < MAX_PASSWORD_LENGTH) { // 현재 입력 길이가 최대 길이(7자리) 미만인 경우에만 입력 받습니다.
 636:	91 05       	cpc	r25, r1
 638:	0c f0       	brlt	.+2      	; 0x63c <__LOCK_REGION_LENGTH__+0x23c>
 63a:	83 ce       	rjmp	.-762    	; 0x342 <main+0x10>
 63c:	fc 01       	movw	r30, r24
 63e:	ef 54       	subi	r30, 0x4F	; 79
 640:	fe 4f       	sbci	r31, 0xFE	; 254
 642:	c0 83       	st	Z, r28
 644:	8c 2f       	mov	r24, r28
                            entered_password[password_index] = key;  // 입력된 키를 버퍼에 저장합니다.
 646:	c0 dd       	rcall	.-1152   	; 0x1c8 <LCD_CHAR>
 648:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
 64c:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
                            LCD_CHAR((unsigned char)key);            // LCD 두 번째 줄에 해당 숫자를 출력합니다.
 650:	01 96       	adiw	r24, 0x01	; 1
 652:	90 93 af 01 	sts	0x01AF, r25	; 0x8001af <__data_end+0x1>
                            password_index++;                        // 인덱스를 증가시킵니다.
 656:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <__data_end>
 65a:	fc 01       	movw	r30, r24
 65c:	ef 54       	subi	r30, 0x4F	; 79
 65e:	fe 4f       	sbci	r31, 0xFE	; 254
 660:	10 82       	st	Z, r1
 662:	6f ce       	rjmp	.-802    	; 0x342 <main+0x10>

00000664 <strcmp>:
 664:	fb 01       	movw	r30, r22
                            entered_password[password_index] = '\0'; // 다음 입력을 위해 널 종료 문자를 추가합니다.
 666:	dc 01       	movw	r26, r24
 668:	8d 91       	ld	r24, X+
 66a:	01 90       	ld	r0, Z+
 66c:	80 19       	sub	r24, r0
 66e:	01 10       	cpse	r0, r1
 670:	d9 f3       	breq	.-10     	; 0x668 <strcmp+0x4>
 672:	99 0b       	sbc	r25, r25
 674:	08 95       	ret

00000676 <strcpy>:
 676:	fb 01       	movw	r30, r22
 678:	dc 01       	movw	r26, r24
 67a:	01 90       	ld	r0, Z+
 67c:	0d 92       	st	X+, r0
 67e:	00 20       	and	r0, r0
 680:	e1 f7       	brne	.-8      	; 0x67a <strcpy+0x4>
 682:	08 95       	ret

00000684 <_exit>:
 684:	f8 94       	cli

00000686 <__stop_program>:
 686:	ff cf       	rjmp	.-2      	; 0x686 <__stop_program>
